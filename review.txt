项目简介：因为之前做个一个轻量级的Web服务器项目，对于一个Web服务器的实现需要基本功能有了一个简单的了解，所以想对于各个模块进行一个抽象封装，以及对于实现一些功能的技术点进行一下改进，所以做了这个项目。
这个项目的每个模块分工都清晰明了。

日志模块：支持流式写日志和格式化风格写日志。支持设置不同级别，支持日志格式的自定义，多日志分离，不同的日志器可以自定义输出路径。
日志器的组成模块：
日志事件类（包含要打印日志的各种信息）
日志事件包装类（将日志器和日志时间包装起来，通过宏定义简化日志模块的使用，当包装器析构的时候，则调用日志器的log方法输出），
日志格式器，保存了一个日志模板，通过内部定义了一个格式化项的单元类，每一种格式都作为改对象的派生类，去解析不同风格的日志格式，他的构造函数中有一个默认的模板，在创建的时候对这个模板进行解析，将解析得到的格式项生成对应的对象，添加到vector集合中，在输出日志时根据vector数组中的格式项对象的顺序，挨个输出要输出的内容。
日志输出器：用于将日志输出到不同的位置，实现了输出到文件和终端上，每个输出器中有一个日志格式器对象。终端是通过将内容流向cout对象中，文件对象是通过打开文件，通过文件流将日志流入到文件中。对于文件，以防中途日志文件删除，所以记录了上次打开的时间，每隔三秒会重新打开文件，如果文件被删除，则会重新创建文件。
日志器：用于写日志，包括日志器的名称，日志输出器集合，日志级别，通过创建不同的日志器将日志输出到不同的位置，通过日志级别可以将低于这个日志级别的日志不进行输出。通过想日志器传入日志时间，日志器就会遍历日志输出器集合，每个输出器根据自己的格式器将日志时间进行格式化输出到指定的位置。
日志器管理类：通过一个map集合保存着一个项目运行中所有的日志器，可以通过日志器名字获得对象的日志器，如果日志器不存在，则生成一个新的日志器，然后加入到map集合中。这个日志器管理类通过单例类来生成，一个项目只有一个日志器管理类。

配置模块：采取约定优于配置的思想，对于已经项目中定义好的配置，可以直接使用，只有当读取到的配置文件的内容和定义的内容不同时，是通过调用回调函数，改变项目中的配置。这里使用yaml来作为配置文件格式，对于读取配置文件，可以将内容存入到普通的数据类型，也支持现有的所有STL容器中，自定义了一组序列化和反序列化的函数运算符重载类，将yaml字符串转为容器对象，将容器对象反序列化为yaml字符串。也支持自定义的对象类型，不过需要在用到的时候自己自定义序列化和反序列化的方法。
配置模块相关的类:
配置参数的基类：里面包含一个配置参数的基本属性和方法，比如名称，描述，以及tostring\fromstring两个纯虚函数。
配置类：这是一个模板类，继承了配置参数的基类，创建时需要传入配置项的类型。还有两个参数是用于序列化和反序列化的函数运算符重载类。用于配置参数的序列化和反序列化。监听器集合，里面包含了一组回调函数，当参数发生改变时，挨个调用这些回调函数，将配置文件里的内容同步到项目中。
配置项管理类：这个类是提供对外的接口，里面是一些静态方法，这个类内部有一个map集合，key是每个配置参数的名称，val是具体的配置项类智能指针，通过LookUp接口，可以实现查询和注册配置项的功能。其还提供了一个静态接口，读取yaml文件，然后解析这个yaml文件，如果map集合中有对应的key值，则判断value值是否相等，如果不相等就修改配置项的值，在修改完之后会调用之前注册的回调函数，通知配置这个参数项的模块更改配置数据。

线程模块：通过pthread封装了线程类，这里创建线程时需要提供线程的回调函数，还维护了两个线程局部变量，维护当前线程指针和线程名称，同时为了解决线程的同步问题，还封装了互斥锁类、信号量、读写锁、自旋锁、原子锁。基于各种锁，又会用一个类去维护这个锁的创建于销毁，就好比智能指针的思想，除了作用域之后，范围锁对象自动析构解锁，避免忘记释放锁。

协程模块：协程是用户态的线程，相当于线程的线程，更轻量级，它的上下文切换是在用户态，一个线程可以创建更多的协程，理论上是可以创建很多的，但是受限于线程的栈内存大小，我们一般用的协程是有栈协程，也就是说需要给每个协程分配一个栈内存空间，当协程进行切换时，栈帧指针及上下文信息就会保存到ucontext结构体中。这里使用了Linux的ucontext结构体来保存协程的上下文。虽然说可以有很多协程，但是一个线程在一个时间只能运行一个协程，只有协程结束或者退出才会执行另一个协程每个协程有两种原语：resume和yield。就是让当前协程运行和退出。 这里简单起见，一个协程只有三种状态，就绪态、运行态、结束态。子协程状态的变化和切换只能和线程主协程来进行。协程可以在运行中途自己yield退出，然后在后面再resume继续执行，再运行结束后会自动调用yield进行协程状态的切换。


协程调度模块：由于协程是用户级线程，协程的切换需要在用户态由用户再进行，所以需要对协程的运行进行调度。 协程的调度模型分为对称协程调度模型和非对称协程调度模型，这里采取的方式是非对称协程调度模型，。这里定义了两个线程局部变量，一个记录正在运行的协程对象，一个记录线程主协程对象。每个子协程退出都只能回到线程主协程，然后由主协程再去切换到下一个子协程来运行。再协程调度类中实现一个线程池，实现N个线程到M个协程的切换，协程会添加到一个队列中，协程去从队列中取协程进行消费，相当于一个生产者消费者模型，当队列为空，就去调度一个idle协程，这个协程的主要工作是不断的查询队列是否为空，与主协程来回切换，直到程序退出，idle协程变为退出状态，结束调度。

IO协程调度模块：
这个模块是继承了协程调度模块，因为再协程调度模块任务队列为空就会进入idle协程，但是idle协程只是一直与主协程来回切换，所以再IO协程调度模块，可以很好的与一些IO任务进行搭配使用，在没有任务是，进入idle协程，而idle协程中封装了epoll函数，支持注册socket的回调任务，当没有任务时，调度器会阻塞再epoll_wait上，等待IO事件的发生，等有可读可写的任务之后再回调主协程进行任务的调度工作。

定时器模块：
实现定时器的常见方式有alarm函数，然后通过信号捕捉来进行定时任务，或者多路复用函数的超时参数，套接字的超时选项SO_RECVTIMEO和SO_SENDTIMEO来实现。对于管理定时器的数据结构一般有升序链表，时间轮（负载均衡的升序链表），时间堆结构。这里采用时间堆来管理定时器，主要是利用了set容器的自动排序功能，然后通过epoll的超时参数实现定时器功能。epoll在设置超时参数时，会去读取下一个定时任务的时间或者5s的最小时间作为超时参数，防止epoll长时间阻塞在这里。在注册定时器时会同时注册一个回调函数，通过一个定时器管理类来管理（set容器），当epoll函数返回，如果是因为定时任务，则会执行对应定时任务的回调函数，如果是可读可写事件，则将改任务添加到协程队列里面，然后跳出idle协程，去工作协程进行协程调度。
相关类：Timer类，记录定时器的超时时间，是否循环，回调函数    TimerManger：通过set集合管理Timer定时器类，提供添加定时器，收集超时定时器，获取下一个超时的定时器等功能。


Hook模块：Hook的是系统底层和创建socket和设置相关的API，以及sleep系列的API。hook的开启是线程粒度的，可以自由选择。通过hook模块，可以使不具异步功能的API展现出异步的能力。
理解：hook的是一些C标准函数库提供的接口，相当于是对底层系统调用的重载，在调用系统函数之前之后实现一些自己的操作。
实现方法：通过动态库的全局符号表的介入功能，用自定义的接口来替换掉同名的系统调用接口。由于系统调用接口基本上是由C标准函数库libc提供的，所以这里要做的事情就是用自定义的动态库来覆盖掉libc中的同名符号，利用系统调用dlsym找到被覆盖掉的libc中的实际系统调用函数，根据hook是否开启，来选择是否则行hook后的系统调用。

ByteArray模块：这个模块是为了读取和发送文件时准备的， 这里是通过维护一个链表，每个链表块4096个字节，可以先把数据存储起来，等准备好数据之后再一次性取出来发送或者处理。

Socket模块：首先封装了一个Address类，这个类包含了要绑定地址的端口号，地址协议族，sockaddr指针，可以直接通过静态方法LookUp获得一个Address对象，然后堆socket系统调用进行封装，如获取socket套接字，bind，accept，connect等，通过传入获取的address对象快速实现建立连接的功能。

TcpServer模块：基于socket模块可以快速建立一个tcp连接，提供简单的API，使用便捷，可以快速绑定一个地址，启动服务，监听钉扣，accept连接，处理socket业务等，然后有个虚函数handleClint方法，后面的业务类可以继承这个Tcpserver类，通过重写这个方法快速实现业务的读写。这个方法的参数时accept接收到的客户端的套接字地址信息。

MySQL模块：实现了一个数据库连接池，通过单例类返回唯一的数据库连接池对象，内部通过信号量来维护指定的连接池资源，通过互斥锁来实现数据库的增删改操作以及回去连接池资源。通过一个list容器维护所有的连接，封装好了增删改的方法，在进行增删改的时候从连接池获取一个连接，然后与数据库进行交互，完成之后再把连接放入连接池。

HTTP模块：首先定义了两个HTTPRequest类和HTTPResponse类，保存请求报文和相应报文的基本信息，包括请求头信息，头信息，body信息。
其次定义了HTTPRequestParser类，用于解析HTTP请求报文，这个类是通过nodejs/http-parse去解析的，通过定义一系列回调函数，当recv读到请求数据之后，就将数据和回调函数传入http_parser_execute函数中，在这些回调函数中将解析到的数据赋值到HTTPRequest中。
定义了HTTPSession类，一个会话类，管理收发消息，里面有两个方法，recvRequest，收到报文，然后将报文信息传入HTTPResquestParser中解析，sendResponse，向请求端发送消息。
定义了servlet类，仿照Java的Servlet，实现了ServletDispatch派发，根据请求url的不同，分发到不同的回调函数，这些回调函数需要提前根据已有页面进行添加的，他是在内部维护了一个map容器，用于url和对应回调函数Servlet的映射。里面有三个参数，HTTPRequest类、HTTPResponse类和HTTPSession类，在回调函数中根据不同的路径，将不同的页面写入reponse类中，最后通过session进行发送。
HTTPServer：继承于TcpServer类，可以快速建立连接，重写了HandClient方法，在这里，注册一个会话类，获得请求报文，然后获得servlet分发器，根据路径将不同的文件写入响应报文类中，然后调用session的send方法发送消息。

整体思路：
提前注册好Servlet，url和回调函数的映射，然后开启HttpServer，开始监听端口。如果accept获取到了连接，就将handlerClient函数与协程的函数荣口绑定，等待协程调度器调度，然后执行连接消息的解析与响应。



难点：
日志的格式解析模块：通过遍历模板字符串，以状态机的模式解析整个字符串，一共有两种状态，正在解析普通字符，正在解析模板字符串，模板字符一般是在百分号后面。记录解析的每一个子项，如果是普通字符，那么key为0，value为普通字符，对于格式化子符，key为1，value为对应格式化字符的关键字，提前定义了每一个字符代表的含义，那么对于时间来说，时间的格式化模板又会在一个花括号里面，也需要在后面单独处理。解析完成之后，根据解析出来的顺序，依次生成对应的模板项对象，存储来日志格式器中。
协程调度模块：难点在于主线程是否参与协程的一个消费工作。用户可以指定线程的个数，也可以指定调度线程是否参与协程队列的消费。如果参与的话，执行流程和其他的其他的子线程执行流程不太一样，其他子线程在创建完成之后就直接从队列消费协程任务，也就是说每个线程只需要记录线程主协程对象和线程子协程对象即可，而调度线程因为要进行协程任务的添加，所以直到调用stop之后，主线程才回去进行执行消费队列里的任务。这里就会产生三个协程，调度器主协程，工作协程，子协程，所以需要同时记录三个线程变量，再完成之后，再回到调度主协程退出。